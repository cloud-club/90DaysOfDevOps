# Containers
### 42일차
애플리케이션을 실행하는 방법은 다양하게 존재한다. 물리적 하드웨어 위에 운영체제와 애플리케이션을 올리는 방법도 있고 클라우드 기반 IaaS 인스턴스에 애플리케이션을 올리는 방법도 있고 PaaS 제품으로 통합될 수도 있으며 컨테이너 위에서 동작되도록 할 수도 있다.

컨테이너와 이미지는 높은 수준에서 설치와 운영을 동일한 목록으로 옮길 수 있고 이미지는 배포 관점에서 컨테이너는 설치와 운영 관점에서 도움이 된다. 그래서 예전에는 물리적 하드웨어 서버를 올려서 쓰는 경우가 많았지만 현대로 오면서 가상머신과 컨테이너를 통한 애플리케이션 배포를 많이 하는 추세이다.

컨테이너는 애플리케이션을 구축하고, 이미지를 통해 독립적으로 쉽게 배포 및 확장할 수 있도록 도와준다. 이미지는 소스코드와 라이브러리, 종속성이 함께 패키징되기 때문에 한 시스템에서 다른 시스템으로 쉽게 확장 가능하다.

### 43일차
docker는 컨테이너 기술 중 하나로 컨테이너를 빌드, 실행 및 관리하기 위한 소프트웨어 프레임워크이다.

각각의 구성 요소는 다음과 같다.
docker engine은 애플리케이션을 빌드하고 컨테이너화하기 위한 오픈소스 컨테이너화 기술이다.
docker desktop은 window나 macos 환경에서 설치하기 쉬운 경량 docker 개발 환경이다.
docker compose는 여러 개의 컨테이너를 띄울 때 사용할 수 있는 도구이다.
dockerhub는 docker registry중 하나로 이미지를 저장하는 중앙 집중식 저장소이다.
dockerfile은 docker 이미지를 빌드하기 위한 텍스트 파일이다.

### 44일차
docker 실습

### 45일차
Dockerfile은 docker 이미지를 빌드하기 위한 텍스트 파일로 docker는 Dockerfile에 있는 지침을 읽어 이미지를 자동으로 빌드한다.
docker 이미지를 구성하는 각 파일을 레이어라고 하고 레이어는 단계적으로 서로 위에 빌드되어 이미지를 형성한다. 각 레이어는 바로 아래 레이어에 종속된다. docker는 이미지로부터 컨테이너를 실행할 때마다 컨테이너 레이어라고 하는 쓰기 가능한 레이어가 추가된다.
Dockerfile 키워드
- FROM : 상위 이미지 지정
- WORKDIR : 작업 dir 설정
- RUN : 컨테이너에 필요한 애플리케이션 및 패키지 설치
- COPY : 특정 위치 파일이나 디렉토리 복사
- ADD : 복사 뿐만 아니라 원격 url를 처리하고 압축 파일의 압축도 풀 수 있다
- ENTRYPOINT : 컨테이너가 시작될 때 항상 실행되는 명령
- CMD : 엔트리포인트로 전달된 인자
- EXPOSE : 컨테이너 애플리케이션에 액세스할 포트 정의
- LABEL : 이미지에 메타데이터 추가

### 46일차
여러 컨테이너에서 더 복잡한 앱을 실행할 수 있는 도구로 Docker Compose가 존재한다. 보통 docker-compose.yml이라는 yaml파일을 사용한다.
`docker compose up -d`을 통해 docker compose를 실행할 수 있고 `docker compose down`을 통해 컨테이너를 삭제할 수 있다.

### 47일차
`docker network` 명령을 통해서 컨테이너 네트워크를 구성하고 관리할 수 있다. 뒤에 list나 inspect를 추가해서 목록을 보거나 상세를 볼 수 있다.
docker desktop을 설치하면 bridge라는 사전 구축된 네트워크가 제공이 된다.
bridge 드라이버는 단일 host 네트워킹을 제공한다.
기본적으로 bridge 네트워크는 새 컨테이너에 할당되므로 네트워크를 지정하지 않으면 모든 컨테이너가 bridge 네트워크에 연결된다.

또한, 배포한 모든 컨테이너는 컨테이너 내 프로세스에 대한 루트 권한을 사용하였는데 유저 권한으로 나누기 위해서는 Dockerfile을 만들때 useradd를 통해 해당 유저를 추가하고 마지막에 USER username을 적어준다.

docker의 대안으로 Podman이 존재한다. Podman은 리눅스 시스템에서 OCI 컨테이너를 개발, 관리, 실행하기 위한 데몬이 없는 컨테이너 엔진이다.

LXC는 사용자가 다시 여러 개의 격리된 리눅스 컨테이너 환경을 생성할 수 이쎅 해주는 컨테이너화 엔진이다. LXC는 별도의 시스템 파일과 네트워킹 기능을 갖춘 여러 리눅스 머신을 생성하기 위한 하이퍼바이저 역할을 한다.

Containerd는 독립형 컨테이너 런타임으로 단순성과 견고성은 물론 이식성까지 제공한다.
# Kubernetes
Kubernetes는 요구사항과 원하는 상태에 따라 컨테이너를 오케스트레이션할 수 있는 기능을 제공하는 플랫폼이다. 컨테이너 오케스트레이션 플랫폼은 이외에도 Docker swarm, apache mesos 등이 있다.
kubernetes는 다음과 같은 이점을 제공한다.
- Service discovery 및 로드 밸런싱
- 스토리지 오케스트레이션
- 자동 bin 패킹
- 자가 복구
- secret 및 config 관리

k8s의 구성 요소
- 노드
  - 컨트롤 플레인 : 클러스터에 대한 전역 결정을 내리고 클러스터 이벤트를 감지 및 응답
  - 워커 노드 : 물리적 머신이거나 VM일 수 있습니다. 각 노드는 하나 이상의 pod를 호스팅
- kubelet : 각 노드에서 실행되는 에이전트로서 컨테이너가 pod에서 실행되고 있는지 확인
- kube-proxy : 각 노드에서 실행되는 네트워크 프록시로, 클러스터 내부 또는 외부의 네트워크 세션에서 pod로의 네트워크 통신을 허용
- 컨테이너 런타임 : 컨테이너 실행을 담당하는 소프트웨어
- 클러스터 : 노드의 그룹
- kube apiserver : REST 작업을 수행하고 다른 모든 구성 요소가 상호 작용하고 pod, 서비스, 응답 컨트롤러 등을 포함하는 API 오브젝트에 대한 데이터의 유효성을 검사하고 구성
- scheduler : 노드에 pod를 할당하는 컨트롤 플레인 프로세스
- 컨트롤러 매니저 : Kubernetes와 함께 제공되는 핵심 제어 루프를 임베드하는 daemon
- etcd : 모든 클러스터 데이터에 대한 백업 저장소로 사용, 가용성이 높은 키 값 저장소
- kubectl : API 서버와 상호 작용
- pods : 논리적 애플리케이션을 구성하는 컨테이너 그룹
- deployments : pods를 선언적 상태에 맞게 관리하는 요소
- ReplicaSets : 원하는 수의 pod을 갖도록 보장, deployments에 따라 pod을 생성하고 확장
- StatefulSets : 상태 저장 애플리케이션을 관리하는 데 사용
- DaemonSets: 연속된 프로세스를 위해 사용, 노드당 하나의 pod을 실행, 주로 모니터링 및 로그 수집에 사용
- Services : pod에 access하기 위한 단일 엔드포인트 제공

### 52일차
Vagrant는 가상 머신의 라이프사이클을 관리하는 cli 유틸리티이다.
virtualbox를 이용해서 여러 개의 가상 머신을 vagrant로 띄우는 과정..
### 53일차
Rancher는 컨테이너를 도입하는 팀을 위한 완벽한 소프트웨어 스택이다. 이 스택은 모든 인프라에서 여러 개의 k8s 클러스터를 관리할 때 발생하는 운영 및 보안 문제를 해결하는 동시에 데브옵스 팀에 컨테이너화된 워크로드를 실행하기 위한 통합 도구를 제공한다.

### 54일차
k8s 배포 방법은 yaml파일과 helm 두가지가 존재한다. 앱을 노출하는 방법 또한 4가지 정도가 존재한다
- ClusterIP
- NodePort
- Load Balancer
- Port forward

aws eks에서는 ingress controller를 이용해서 elb를 앞단에 두고 뒤에 nodeport로 앱을 노출하는 방법을 사용한다.

helm은 k8s를 위한 패키지 관리자로 차트를 이용해서 애플리케이션 리소스를 구성할 수 있다.

### 55일차
StatefulSet은 k8s가 스케쥴링 위치에 관계없이 유지 관리하는 고유하고 영구적 ID와 안정적인 호스트 이름을 가진 pod의 집합을 나타낸다. 특정 StatefulSet pod의 상태 정보 및 기타 복원력 있는 데이터는 StatefulSet과 연결된 영속성 디스크 스토리지에 유지된다.
StatefulSet pod는 모든 스케줄링에 걸쳐 영구 식별자를 가지고 있고 데이터베이스에 쓰고 읽어야 하는 워크로드가 필요할 때, 데이터 불일치를 초래할 수 있기 때문에 두 개의 pod가 인식 없이 동시에 쓰게 할 수 없게 하기 위해서 필요하다.

이를 위해 저장해야할 볼륨의 필요성이 대되는데 기본적으로 PV라는 영속성 볼륨을 사용한다.
PV란 데이터를 저장하기 위한 클러스터 리소스로 yaml 파일을 통해 생성이 되고 실제 물리적 스토리지 NAS가 필요하다. PV만 있어도 사용은 할 수 있지만 애플리케이션에서 사용하기 위해선 PVC라는 PV claims가 필요하다. 이는 yaml 파일을 통해 생성이 되고 PVC는 pod 구성에서 사용하게 된다. 이외에도 pod은 여러 가지 유형을 볼륨(ConfigMap, Secrets)을 사용하게 된다.

Ingress란 애플리케이션을 노출하는 더 나은 방법을 제공하며, 이를 통해 Kubernetes 클러스터 내에서 라우팅 규칙을 정의할 수 있다.