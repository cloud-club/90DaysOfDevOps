<div align=center><h3> 1.What is and why do we use DevOps </h3></div>
<br/>


## DAY 1

데브옵스란?

- 소프트웨어 개발에서 좀 더 현명하게 일하는 방법
- 소프트웨어 개발과 운영의 통합
- 제품 초기 아이디어부터 실제 운영 서비스로 전달되기까지의 시간을 단축하는 것이 목적
- 소프트웨어 배포 프로세스를 더 작고 자주 배포하는 방식
- 개발, 테스트, 배포는 데브옵스 팀과 함께함 - 자동화 활용 필요
</br>

## DAY 2

개발 파트 - 애플리케이션 작성 및 테스트

운영 파트

- 서버에 배포 및 유지
- 프로그래밍 X, 개발 업무, 시스템, 도구 그리고 전반적인 과정에 대한 개념 이해 필요 → 필요한 서비스와 통신 방법, 테스트, 요구사항 포함
- 애플리케이션 실행 위한 서버 생성 및 설정 필요 - 데브옵스 엔지니어의 역할
- 서버 보통 리눅스 사용, 네트워크 지식 필요
- 가상화, *IaaS (클라우드 인프라 서비스), 컨테이너화에 대한 이해도 필요
- 새 애플리케이션 버전을 어떻게 출시하는가? - 데브옵스 엔지니어의 핵심 업무

*IaaS (Infrastructure as a Service) : 물리적 자원을 가상화하여 제공

<img src="https://github.com/cloud-club/90DaysOfDevOps/assets/110540359/1129ea31-e40c-4354-adf1-78ad8e970dbc"/>

</br>

## DAY 3

데브옵스 수명 주기

1. 개발
    - 요구사항 도출 및 이를 기반으로 애플리케이션 개발
    - IDE + 프로그래밍 언어 필요
    - 버전 관리 필요 - Git
2. 테스팅
    - 다양한 환경과 선택한 언어에서 코드 테스트
    - QA(Quality Assurance) - 소프트웨어 제품, 서비스의 품질 관리 및 개선하는 역할을 수행
        - 버그 테스트
        - 테스트 환경 시뮬레이션시 컨테이너 사용 → 물리적 또는 클라우드 인프라의 비용 오버헤드 개선
            
            왜?? 컨테이너 자체의 특징을 생각해보면 된다
            
            컨테이너는 운영체제 수준에서 격리된 환경 제공 = 하나의 호스트 운영체제로 여러개 컨테이너 생성 가능 = 자원 공유 = 가상 머신과 비교했을 때 더 가볍고 빠르다 = 비용도 덜 듦
            
            컨테이너 기술은 스케일링 능력이 있음 = 테스트 환경을 필요에 따라 확장하거나 축소 가능 = 최적화
            
    - 테스팅은 지속적 통합의 일부로 자동화 될 수 있음 - 테스트 시간을 줄여 더 빠르고 많은 기능 개발 가능
3. 통합
    - 커밋할때마다 애플리케이션은 자동화된 테스트 단계 거침 - 다음 단계로 넘어가기 전에 문제나 버그 조기에 발견
    - 여기까진 기존 개발 팀이 진행
    - 테스트도 끝내고 배포 준비 완료!
4. 배포
    - 사용자가 사용할 수 있도록 프로덕션에 배포
    - 코드를 서버에 배포하는 단계
    - Application Configuration Management, Infrastrcutre as Code가 배포 단계에서 중요
    - 쿠버네티스 같은 플랫폼 사용(컨터이너 *오케스트레이션 및 사용자가 원하는 상태 사용할 수 있도록 함)
    
    *오케스트레이션 : 컨테이너, 가상 머신 또는 다른 IT 리소스와 서비스를 효과적으로 관리하고 운영하는 프로세스 또는 도구의 사용  
5. 모니터
    - 사용자 경험 확인 필요
    - 애플리케이션 성능 지속적 모니터링 → 향후 릴리즈에서 개선
    - 구현된 기능, 개선 방향에 대한 피드백 수집
    - 안정성 중요! 관찰 가능성, 보안 및 데이터 관리 영역도 모니터
</br>

## Day 4

DevOps & Agile

- 둘은 서로 독립적인 개념이지만 융합중

</br>
애자일

- 큰 결과물 한번에 출시 < 작은 결과물을 더 빠르게 제공
- 소프트웨어의 반복적 개발 → 점진적으로 업데이트해서 새 버전 출시
- 최종 목표 : 사용자에게 최적의 경험을 제공하는 것

</br>
데브옵스

- 소프트웨어 개발자와 운영 전문가 간의 협력을 기반으로 하는 배포 관행
- 장점 : 간소화된 개발 프로세스, 잘못된 커뮤니케이션 최소화

</br>
둘의 차이점

- different participants
    - 애자일 : 최종 사용자와 개발자 간의 커뮤니케이션 최적화 → 외부 지향적(고객)
    - 데브옵스 : 개발자와 운영, 팀원을 대상으로 함 → 내부 관행
- 팀
    - 애자일 : 소프트웨어 개발자와 프로젝트 관리자에게 적용
    - 데브옵스 : 제품 주기의 모든 단계에 관여(개발, QA, 운영) → 애자일팀에 소속될수 있다!
- 적용된 프레임워크
    - 애자일 : Scrum > Kanban > Lean > Extreme > Crystal > Dynamic > Feature - Driven
        
        (아무튼 구체적인 방법론이 있다!)
        
    - 데브옵스 : 구체적인 방법론 x
        
        but 코드형 인프라, 코드형 아키텍쳐, 모니터링, *self-healing, 엔드투엔드 테스트 자동화와 같은 관행 장려
        
- 피드백
    - 애자일 : 사용자
    - 데브옵스 : 이해관계자와 팀 자체의 피드백
- 대상 영역
    - 애자일 : 배포 및 유지관리 < 소프트웨어 개발
    - 데브옵스 : 개발 물론 중요 but 모니터링, 고가용성, 보안 및 데이터 보호와 같은 배포 및 릴리스 후 단계도 중요
- 문서
    - 애자일 : 문서화 및 모니터링 < 유연성, 당면한 작업
    - 데브옵스 : 프로젝트 문서는 필수임
- 위험요소
    - 애자일 : 우선순위와 요구사항이 계속 변함 → 예측 및 평가 어려움
    - 데브옵스 : 용어에 대한 오해와 적절한 도구의 부재로부터 비롯
- 사용되는 툴들
    - 애자일 : JIRA, TRELLO, SLACK, ZOOM, SURVEYMONKEY 등 커뮤니케이션 협업, 피드백 처리에 중점
    - 데브옵스 : Jenkins, GitHub Actions, Bucket 등 팀 커뮤니케이션, 소프트웨어 개발, 배포 및 통합을 위함

</br>
애자일과 데브옵스의 통합

- 장점
    - 유연한 관리와 강력한 기술
    - 애자일은 데브옵스팀이 우선순위를 보다 효율적으로 소통하는데 도움
    - 데브옵스 관행을 위해 지불해야 하는 자동화 비용은 신속하고 자주 배포해야하는 애자일 요구 사항에 따라 정당화 된다
    - 애자일 방식을 채택하는 팀은 협업을 개선하고 팀의 동기를 높이며 직원 이직률은 낮춘다… ← 지극히 주관적인 견해인듯
    - 제품 품질 향상
- 방법
    1. 개발 팀과 운영 팀 통합
    2. 빌드 및 운영 팀을 만들고 모든 개발 및 운영 관련 문제를 데브옵스 팀 ( = 빌드 및 운영팀)에서 논의
    3. 스프린트에 대한 접근 방식 변경, 우선순위 지정 → 개발 작업과 동일한 가치를 지닌 데브옵스 작업 제공할 것 
        
        개발팀과 운영팀이 다른팀의 workflow와 발생 가능한 문제에 대해 의견을 교환하도록 장려할 것
        
        ⇒ 스프린트가 약간 개발 중점이었다면 여기에 데브옵스 작업 추가
        
    4. 모든 개발 단계에 qa 포함
    5. 올바른 도구 선택
    6. 가능한 모든 것 자동화
    7. 가시적인 수치 결과물을 사용하여 측정 및 제어

 *self-healing : 소프트웨어 시스템이 문제가 발생할 때 자동으로 문제를 감지하고 복구하는 능력
</br>

## Day 5
 
<img src="https://github.com/cloud-club/90DaysOfDevOps/assets/110540359/a04ae9d5-e517-44b0-bc14-715bbce85508"/>

계획

- 계획 단계에 데브옵스 엔지니어가 참여 → 앞으로 어떤 일이 발생할지 파악하고 개발팀의 결정이나 경로에 영향을 미치고, 데브옵스 엔지니어가 구축한 인프라로 작업하도록 돕거나 다른 경로를 다를때 더 나은 방향으로 안내할 수 있는 기회
- 잘못되기 전에 계획할 때 껴들어서 미리 협력하자

코드 작성

- 코드 작성하는 동안 인프라에 대한 이해도를 높임 ( 어떤 서비스 사용가능한지, 서비스와 어떻게 상호작용할 수 있는지)
- 해당 코드 병합도 중요

빌드

- 첫번째 자동화 프로세스
- 코드를 가져와서 언어에 따라 변환, 컴파일, 도커 이미지 생성 가능
- CI 파이프라인을 통해 이러한 프로세스 자동화
- 빌드 자동화해두면 수동으로 작업할 필요 없이 효율적이고 일관성 있는 작업 수행 가능

테스트

- 프로덕션에 문제가 발생하지 않도록 최소화 하기 위한 시도

릴리즈

- 깃헙 리포지토리나 깃 리포지토리에서 가져온 코드나 빌드된 도커 이미지를 프로덕션 서버에 배포하기 위해 레지스트리나 리포지토리에 저장

배포

- 프로덕션 환경에 코드 적용하는 과정

운영

- 고객이 사용할때 발생하는 문제 파악 및 대처방안 모색
- 서버 자동 확장 기능이 예시
- 자동화하면 좋음

모니터링

- 메모리 사용률, CPU 사용률, 디스크 공간, API 엔드포인트, 응답 시간, 엔드포인트가 얼마나 빨리 응답하는지 등을 모니터링
- 로그 사용하면 시스템에 액세스 안해도 확인 가능

다듬기 & 반복

- 수행 프로세스 검토 및 개선 부분 찾음

지속

- CI/CD (Continous Integration/Continous Delivery/Continous Deployment)
- Continous Delivery(지속적 제공)
    - 계획 > 코드 작성 > 빌드 > 테스트
    - 공유 레포지토리로 자동으로 Release
    - sw를 제공가능한 상태로 유지 = 언제든지 배포 가능한 상태로 유지
- Continous Integration (지속적 통합)
    - 어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합하는 것을 의
    - 지속적 제공 + 릴리즈 단계
    - 계획 > 코드 > 빌드 > 테스트 > 릴리즈
    - 목표
        - 버그 신속하게 찾아 해결
        - 소프트웨어 품질 개선
        - 새로운 업데이트의 검증 및 릴리즈의 시간 단
- Continous Deployment(지속적 배포)
    - Production 레벨까지 자동으로 deploy
    - 성공적인 CI 릴리즈 = Continuous Deployment = 배포 > 운영 > 모니터링
      
<img src="https://github.com/cloud-club/90DaysOfDevOps/assets/110540359/cb8591ea-2eaf-42fb-a08b-8cb0d9f6f6eb"/>

</br>

## Day 6

데브옵스 성공 사례

아마존

- 2010년 물리적 서버 공간을 aws 클라우드로 이전 → 아주 작은 단위로 용량 확장 및 축소해서 리소스 절약
- 지속적 배포 프로세스 채택 = 개발자가 원할때 서버에 코드 배포
- 새 sw 평균 11.6초만에 배포 가능

넷플릭스

- It 운영에 의존하지 않고도 배포 가능한 웹 이미지로 코드를 자동으로 빌드
- 이미지가 업데이트 되면 맞춤형으로 구축된 웹 기반 플랫폼 사용해 넷플릭스 인프라에 통합
- 이미지 배포 실패? 롤백되어 이전 버전으로 트래픽 다시 라우팅되도록 지속적인 모니터링

etsy

- 넷플, 아마존보다 빨리 개발자가 코드 배포할 수 있도록 함

데브옵스에 대해 살펴본 첫 며칠의 요약

- 데브옵스는 전체 애플리케이션 개발 라이프사이클인 개발, 테스트, 배포, 운영을 단일 팀이 관리할 수 있도록 하는 개발과 운영의 조합
- 데브옵스의 주요 초점과 목표는 개발 라이프사이클을 단축하면서도 비즈니스 목표와 긴밀하게 연계하여 기능 및 수정 사항을 자주 제공하는 것
- 데브옵스는 소프트웨어를 안정적이고 신속하게 배포하고 개발할 수 있는 소프트웨어 개발 접근 방식 = 지속적인 개발, 테스트, 배포, 모니터링

<br/>
<div align=center><h3> 4.Understand Networking </h3></div>
<br/>

## Day 21

넷데브옵스 (네트워크 데브옵스)

- 네트워크에 데브옵스 원칙과 관행을 적용하고,
    
    버전 제어 및 자동화 도구를 네트워크 생성, 테스트, 모니터링 및 배포에 적용하는 것
    
- *프로비저닝, 구성, 테스트, 버전 제어 및 배포와 관련된 자동화 원칙을 사용
    
    → 자동화를 통해 전반적으로 배포 속도, 네트워킹 인프라의 안정성, 지속적인 개선 가능, 테스트 완료되면 여러 환경에서 프로세스 공유
    
</br>
네트워킹 기본 사항

- 호스트 : 트래픽을 보내거나 받는 모든 장치
- IP 주소 : 각 호스트의 신원
- 네트워크 : 호스트 간에 트래픽 전송, 비슷한 연결이 필요한 호스트의 논리적 그룹/ 네트워크 호스트는 동일한 ip 주소 공간 공유
- 스위치 : 네트워크 내에서 통신 촉진, 스위치는 호스트 간 데이터 패킷 전달
- 라우터 : 네트워크 간의 통신을 용이하게 함
    - 트래픽 제어 지점(보안, 필터링, 리디렉션) 제공
    - 라우팅 테이블 : 연결된 모든 네트워크에 대한 정보를 담고 있음
    - 연결된 네트워크의 ip 주소를 가짐 → 게이트웨이 (각 호스트가 로컬 네트워크에서나가는 통로)

</br>
스위치 vs 라우터

- 라우터 : 네트워크 간! 데이터 이동 프로세스 / 라우팅 목적
- 스위칭 : 네트워크 내! 데이터 이동 프로세스 / 스위칭 목적

</br>
네트워크 장비

- Access Points : 무선 네트워크에서 무선 디바이스가 유선 네트워크에 연결할 수 있도록 하는 장치 - 무선 네트워크 신호 제공 (공유기 생각)
- 방화벽 : 네트워크 보안 유지 장치, 불법적인 접근 및 악성 트래픽 차단하여 네트워크 보호
- 로드밸런서 : 네트워크 트래픽을 여러 서버 또는 리소스로 분산시켜서 부하를 고르게 분배하는 역할
- Layer 3 switch : 네트워크에서 스위칭과 라우팅을 모두 수행하는 장치, IP 주소를 기반으로 데이터를 스위칭하고 다른 서브넷 간의 통신을 라우팅함
- IDS/IPS (Intursion Detection System/Intrusion Prevention System) : 네트워크에서 악성 행위나 침입을 탐지하고 방지하는 시스템, 침입 시도를 감지하고 적절히 대응
- 프록시 : 클라리언트와 서버 중개 역할
- VIRTUAL SWITCHES
- VIRTUAL ROUTERS

*프로비저닝: **IT 인프라를 생성하고 설정하는 프로세스**로서, 다양한 리소스에 대한 사용자 및 시스템 액세스를 관리하는 데 필요한 단계를 포함 → 배포 초기 단계
</br>

## Day 22

OSI 7 계층

- 네트워크에 대한 규칙이 7계층으로 나뉜 것 → 궁국적으로 두 호스트 사이에 데이터를 공유하기 위함
- 서로 다른 제품과 소프트웨어 간의 상호 운용성을 지원하기 위해 컴퓨팅 기능을 보편적인 규칙과 요구 사항으로 특성화 한것

</br>
Physical layer

- 물리적 수단을 통해 호스트 간 데이터 전송
    - 이더넷, fibre(섬유), 허브
- bit ( 0 or 1 )로 데이터 전송

</br>
Data link layer

- 데이터가 프레임으로 패키지화 되는 노드 간 전송 가능하게 함
- 물리 계층에서 발생하는 오류 수정 가능
- MAC 주소 사용 - 48bits

</br>
Network layer

- End to end 전송
- ip 주소 사용
- 라우팅 여기서 일어남

</br>
Mac주소와 IP주소

- 맥 주소는 호스트에서 스위치/라우터로만 이동하여 HOP에 중점을 둠

</br>
Transport layer

- 데이터 스트림 구분
- PORT 사용 (IP는 주소, POST는 호수)
- SERVICE TO SERVICE
- TCP/UDP단

</br>
Session / Presentation / Application layer

- 다른 호스트로 전송할 데이터 생성

</br>

![4-1](https://github.com/cloud-club/90DaysOfDevOps/assets/110540359/fbdc77eb-9180-46d4-92f4-745415ff4577)

- OSI 단계마다 붙는 헤더에 따라서 이름이 다르다
</br>

## Day 23

네트워크 프로토콜? 인터넷 표준을 구성하는 일련의 규칙과 메시지

ARP - 주소 확인 프로토콜

- Layer2(Data link layer)에서 IP주소를 MAC주소에 연결

</br>
FTP - 파일 전송 프로토콜

- 애플리케이션 계층에 있음
- 소스에서 대상으로 파일 전송
- 인증되지만 익명으로 액세스 사용하도록 구성한 경우 사용 가능

</br>
SMTP - 단순 메일 전송 프로토콜

- 전자 메일 전송에 사용

</br>
HTTP - 하이퍼 텍스트 전송 프로토콜

- 웹사이트 엑세스

</br>
SSL - 보안 소켓 계층 / TLS - 전송 계층 보안

- 네트워크를 통해 안전한 통신을 제공하는 암호화 프로토콜
- 특히 HTTPS 보호하는데 사용

</br>
HTTPS - SSL/TLS로 보호되는 HTTP

- 호스트 간 데이터 교환디는 동안 인증, 개인 정보 보호 및 무결성 제공

</br>
DNS - 도메인 이름 시스템

- IP주소와 도메인 주소 매핑
- 호스트, 서비스 및 기타 리소스에 연결할 수 있도록 함

</br>
DHCP - 동적 호스트 구성 프로토콜

- 인터넷 액세스 및 파일 전송 위해 필요한 요소
    - IP주소 - 고유주소
    - 서브넷 마스크 - 우편번호? 
    - 기본 게이트웨이 - LAYER3 연결 제공하는 라우터의 IP - 동네 나가는 도로
    - DNS
- 각 호스트마다 네가지를 가지면 시간 너무 오래 걸림 → DHCP가 네트워크 범위 결정하고, 이 프로토콜이 네트워크에서 사용 가능한 모든 호스트에 배포 = 동적으로 4가지 임의로 정해서 배포(일정 기간만)

</br>
서브넷

- IP 네트워크의 논리적 세분화
- 대규모 네트워크를 더 효율적으로 실행할 수 있는 더 작고 관리하기 쉬운 네트워크로 나눔
- 라우터는 서브넷 간의 통신을 관리
- 서브넷 크기는 연결 요구 사항과 사용되는 네트워크 기술에 따라 달라짐
- 장점 : IP 주소 재할당 가능, 네트워크 혼잡, 간소화, 네트워크 통신 및 효율성 완화, 네트워크 보안 향상
</br>

## Day 24

네트워크 자동화의 주요 요인

- 민첩성 달성
- 비용 절감
- 오류 제거
- 규정 준수 보장
- 중앙 집중식 관리

자동화 방법에 정답은 없고 적합한 것을 찾는 것이 중요!

</br>
네트워크 자동화에 대한 접근 방식

1. 작업을 식별하고 네트워크 변경 요청에 대한 검색 수행 → 솔루션 자동화할 가장 일반적인 이슈와 문제 파악
    - 현재 수동으로 처리하고 있는 모든 변경 요청과 workflow 목록 작성
    - 가장 일반적이고 시간이 오래 걸리며 오류가 발생하기 쉬운 활동 파악
    - 비즈니스 중심 접근 방식을 취하여 요청의 우선순위 정하기
    - 이는 자동화 프로세스를 구축하기 위한 프레임워크 → 자동화해야하는 작업과 자동화 하지 않아야하는 작업 구분
2. 작업 나누기 & 서로 다른 네트워크 기능이 어떻게 작용하고 상호 작용하는지 분석
    - 인프라/네트워크팀 : 애플리케이션 배포 위한 여러 계층에서 변경 티켓 받기
    - 네트워크 서비스를 기반으로 여러 영역으로 나누고 서로 어떻게 상호 작용하는지 이해
        - 애플리케이션 최적화
        - ADC(애플리케이션 전송 컨트롤러)
        - 방화벽
        - DDI (DNS, DHCP, IPAM)
        - 라우팅
        - 기타
    - 다양한 종속성을 파악하여 비즈니스 및 문화적 차이를 해결하고 팀 간 협업 유도
3. 재사용 가능한 정책, 재사용 가능한 서비스 작업, 프로세스 및 입출력 정의하고 단순화
    - 다양한 서비스, 프로세스 및 입출력을 위한 오퍼링 정의
    - 배포 프로세스 간소화 → 신규 워크로드와 기존 워크로드 모두의 시장 출시 기간 단축
    - 표준 프로세스 마련 → 멀티스레드 접근 방식과 제공을 위해 개별 요청에 따라 프로세스를 순서화 및 조정
4. 정책을 비즈니스별 활동과 결합
    - 서비스 작업이 상호 운용 가능한지 확인
    - 증분 서비스 작업을 연결해 비즈니스 서비스를 만들 수 있도록 정렬
    - 필요에 따라 서비스 작업을 연결하고 다시 연결할 수 있는 유연성 제공
    - 셀프 서비스 기능을 배포하고 운영 효율성 개선할 수 있는 기반 마련
    - 감독 및 규정 준수에 지속적으로 기여할 수 있도록 다양한 기술 스킬셋 허용
5. 가용성과 서비스를 유지하면서 정책과 프로세스 반복하여 추가 및 개선
    - 기존 작업을 자동화하여 작게 시작하기
    - 자동화 익숙 → 자동화를 통해 이점 얻을 수 있는 다른 영역 식별 가능
    - 반복을 통해 가용성 유지하면서 민첩성 점진적 추가
6. 네트워크 서비스를 오케스트레이션
    - 애플리케이션 신속하게 제공 → 배포 프로세스의 자동화
    - 자동화 배포 순서 제어할 수 있는 END TO END 오케스트레이션 준비

</br>
네트워크 자동화 도구

- 운영체제 - 리눅스

- IDE - VSCODE

- 구성관리 - ANSIBLE

- 에이전트리스
  - SSH만 필요
  - 대규모 지원 커뮤니티
  - 다양한 네트워크 모듈
  - 푸시 전용 모델
  - YAML로 구성
  - 오픈 소스!

- CI/CD - 젠킨스(변경 사항이 있는지 GIT 리포지토리 모니터링하고 변경시작)

- 버전 관리 - GIT은 로컬 / GITHUB, GITLAB, BITBUCKET 리포지토리 정의 및 코드 업로드

- 언어 - 파이선

- API 분석 - POSTMAN 
  - POST >>> 리소스 객체를 생성합니다.
  - GET >>> 리소스를 검색합니다.
  - PUT >>> 리소스를 생성하거나 교체합니다.
  - PATCH >>> 리소스 오브젝트를 생성하거나 업데이트합니다.
  - DELETE >>> 리소스를 삭제합니다.


