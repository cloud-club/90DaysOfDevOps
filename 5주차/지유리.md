# Day84. 데이터 관리 개요

- 데이터 주제의 세 가지 핵심 영역
    1. **정확성** : 프로덕션 데이터 및 백업 데이터의 정확성 및 장애 발생 시 가능한 빨리 복구가 가능해야 한다. 
    2. **일관성** : 데이터 서비스가 여러 위치에 있더라도, 프로덕션의 경우 모든 데이터 위치에서 데이터들의 일관성을 유지해야한다. 특히 백업, 복제본 등 사본 수준에서도 일관성을 보장해야 한다.
    3. **보안** : 적절한 사람만 데이터에 액세스할 수 있도록 해야한다. 

# Day85. 데이터 서비스

> 우리가 접하는 가장 흔한 데이터 서비스는 데이터 베이스이다. 다양한 DB와 그 사용 사례에 대해 알아보자.
> 

올바른 데이터 서비스를 선택하는 것은 애플리케이션의 성능과 확장성 측면에서 중요한 결정이 된다.

### Key-value

- key-value 방식을 사용하는 비관계형 데이터베이스
- 고도의 파티셔닝, 엄청난 규모의 수평 확장 가능
- Redis
    - 분산형 인메모리 key-value 데이터베이스, 캐시 및 메세지 브로커
    - 빠르지만 공간 제한이 있고, 쿼리나 조인이 없어 데이터 모델링 옵션이 제한적이다.
    - Best for: 캐싱, Pub/Sub, 리더보드, **쇼핑 카트**
    - 일반적으로 다른 영구 데이터 레이어 위에 캐시로 사용된다.

### Wide-Column

데이터 저장소를 여러 서버 또는 데이터베이스 노드에 분산할 수 있는 유연한 컬럼을 구성한다. 다차원 매핑을 사용하여 컬럼, 행, 타임스탬프로 데이터를 참조하는 NoSQL DB이다.

- Cassandra
    - 분산형 Wide Column DB, 여러 프로덕션 서버에서 대량의 데이터를 처리하도록 설계되어 단일 장애 지점없이 고가용성을 제공한다.
    - **스키마가 없어 비정형 데이터를 처리할 수 없지만, 일부 워크로드에는 이점으로 작용할 수 있다.**
    - Best for: 시계열, 과거 기록, 많은 쓰기, 적은 읽기

### Document-Oriented

- MongoDB, Couchbase
- Best for: 대부분의 애플리케이션, 게임, IoT

### Relational (관계형)

- ACID(원자성, 일관성, 격리성, 내구성)은 오류, 정전 및 사고에서도 `데이터 유효성`을 보장하기 위한 데이터베이스 트랜잭션의 일련의 속성이다.
- Best for: 대부분의 애플리케이션
- 비정형 데이터에는 적합하지 않다,

## Graph

- Table이나 Document 대신 Node와의 `관계`를 저장한다. 데이터는 사전 정의된 모델에 제한되지 않고 저장되므로 매우 유연한 방식으로 데이터를 사용할 수 있다.
- Neo4j
    - Best for: 그래프, 지식 그래프, 추천 엔진

### 검색 엔진

데이터 콘텐츠 검색 전용으로 사용되는 비관계형 데이터베이스의 한 유형, 인덱스를 사용해 데이터 간의 유사한 특성을 분류하고 검색 기능을 용이하게 한다.

- ElasticSearch

### Multi-model

여러 데이터 모델을 지원하도록 설계된 데이터베이스 관리 시스템

- *Fauna는 네이티브 GraphQL을 통해 안전하고 확장 가능한 클라우드 API로 제공되는 유연하고 개발자 친화적인 트랜잭션 데이터베이스*
- Best for: 데이터 모델 선택에 얽매이지 않는 경우, ACID 준수, 빠름,  프로비저닝 오버헤드 없음

# Day86. 플랫폼 백업

데이터 보호 : 고가용성, 인프라 장애에 대한 복원력 확보 → 데이터 사본이 필요하다.

### 백업 방법론

- 3-2-1 방법론
    - 3 Copies of your data
        - **중요 데이터에 대해 기본 데이터 1개, 백업 데이터 2개의 카피본 총 3개를 보관합니다.**
    - 2 Different media types
        - **서로 다른 위험으로부터 보호하기 위해 2가지 서로 다른 미디어 유형에 보관하십시오. ⇒ 다른 장치에 백업 데이터를 저장해라.**
    - 1 Offsite
        - **복사본 하나는 오프사이트(예: 집 또는 업무 시설 외부)에 보관하십시오. ⇒ 물리적으로 완전히 분리된 곳에 보관해라.**

데이터의 첫 번째 복사본/백업은 `복구 속도를 고려하여` 가능한 한 프로덕션 시스템에 가깝게 저장해야한다.

### 백업 시나리오

> Kopia를 이용한 백업 시나리오
> 

 [Kopia 설치 링크](https://kopia.io/docs/installation/#macos-gui-installer)

- 레포지토리 생성 후 스냅샷 생성하는 실습
- 스냅샷 생성 중 Files → Ignore Files 옵션에 2022/를 입력하면 2022 폴더를 제외하고 스냅샷이 생성된 것을 확인할 수 있다.

![스크린샷 2023-10-11 오후 7.57.41.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/b0e4dcaf-d5ab-427a-b2fe-18ed3c40b02e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.57.41.png)

# Day87.  백업 및 복구 실습

> K8S의 워크로드 보호하기
> 

k8s로 백업을 수행하기위해 minikube에 `volumesnapshots` 및 `csi-hostpath-driver` 애드온을 추가하여 실행한다.

```bash
minikube start --addons volumesnapshots,csi-hostpath-driver --apiserver-port=6443 --container-runtime=containerd -p 90daysofdevops --kubernetes-version=1.21.2
```

클러스터가 실행되면 Kasten K10을 사용할 수 있도록 volumesnapshotclass에 주석을 단다.

```bash
kubectl annotate volumesnapshotclass csi-hostpath-snapclass \
    k10.kasten.io/is-snapshot-class=true
```

기본 저장소 클래스를 표준 저장소 클래스에서 csi-hostpath 저장소 클래스로 변경한다.

```bash
kubectl patch storageclass csi-hostpath-sc -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}'
```

helm install k10 kasten/k10 --namespace=kasten-io --set global.persistence.storageClass=csi-hostpath-sc --set auth.tokenAuth.enabled=true --set injectKanisterSidecar.enabled=true --set-string injectKanisterSidecar.namespaceSelector.matchLabels.k10/injectKanisterSidecar=true --create-namespace

### Kasten K10 배포하기

```bash
# Kasten Helm 레포지토리 추가
helm repo add kasten https://charts.kasten.io/

# Kasten k10 배포
helm install k10 kasten/k10 --namespace=kasten-io --set auth.tokenAuth.enabled=true --set injectKanisterSidecar.enabled=true --set-string injectKanisterSidecar.namespaceSelector.matchLabels.k10/injectKanisterSidecar=true --create-namespace
NAME: k10
LAST DEPLOYED: Wed Oct 11 19:35:53 2023
NAMESPACE: kasten-io
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Thank you for installing Kasten’s K10 Data Management Platform 6.0.9!

Documentation can be found at https://docs.kasten.io/.

How to access the K10 Dashboard:

To establish a connection to it use the following `kubectl` command:

`kubectl --namespace kasten-io port-forward service/gateway 8080:8000`

The Kasten dashboard will be available at: `http://127.0.0.1:8080/k10/#/`
```

포트포워딩 후 http://127.0.0.1:8080/k10/#  주소로 k10 대시보드에 접속한다.

```bash
kubectl --namespace kasten-io port-forward service/gateway 8080:8000
```

대시보드 접근을 위해 아래 명령으로 토큰을 확인한다.

```bash
TOKEN_NAME=$(kubectl get secret --namespace kasten-io|grep k10-k10-token | cut -d " " -f 1)
TOKEN=$(kubectl get secret --namespace kasten-io $TOKEN_NAME -o jsonpath="{.data.token}" | base64 --decode)

echo "Token value: "
echo $TOKEN
```

삭제하기

```bash
helm uninstall k10  --namespace=kasten-io
```

---

# Day88. 애플리케이션 중심 백업
설치가 제대로 되지 않음 .. 😵‍💫
> Kanister (https://kanister.io/)
> 

Kanister는 Kasten이 만든 오픈소스 프로젝트로, k8s에서 애플리케이션 데이터를 관리할 수 있다. 

Kanister는 Kubernetes 커스텀 리소스를 사용한다.

- Kanister를 배포할 때 설치되는 주요 커스텀 리소스
    - `Profile` - 백업을 저장하고 복구할 대상 위치입니다. 가장 일반적으로는 오브젝트 스토리지입니다.
    - `Blueprint` - 데이터베이스를 백업 및 복구하기 위해 수행해야 하는 단계가 Blueprint에 유지되어야 합니다.
    - `ActionSet` - 대상 백업을 Profile로 이동하고 복원 작업을 수행하는 동작입니다.
    

처음 Kanister를 배포하면 Controller, Blueprint, Database Workload가 배포된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/b710fdc4-b9d9-45ee-acae-e5b1e5bfde2c/Untitled.png)

ActionSet은 Kanister함수를 사용하여 백업을 대상 레포지토리(Profile)로 push한다.

![스크린샷 2023-10-11 오후 8.36.45.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/01ae1f7c-bcbb-462e-94ba-77f185d9c561/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.36.45.png)

해당 작업 완료/실패하면 해당 상태가 ActoinSet에서 업데이트된다.

![스크린샷 2023-10-11 오후 8.37.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/e7fe9cfd-5b0c-4c46-956c-2834b7f98427/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.37.04.png)

### Kanister 배포

```bash
helm repo add kanister https://charts.kanister.io/

helm -n kanister upgrade --install kanister --create-namespace kanister/kanister-operator

kubectl -n kanister get po
```

# Day89. 재해 복구
설치가 제대로 되지 않음 .. 😵‍💫

---
# 1. DevSecOps

# Day2. DevSecOps 개요

`DevSecOps` : 개발, 보안 및 운영 팀을 하나로 모아 안전한 소프트웨어 애플리케이션을 구축하고 유지 관리하는 것을 목표로 하는 소프트웨어 개발 접근 방식으로, 개발 프로세스의 필수적인 부분이다.

### DevSecOps VS DevOps

- 중점을 두는 부분
    - DevOps: 소프트웨어 릴리스의 속도, 신뢰성 및 품질을 향상시키기 위해 개발자와 운영 직원 간의 협업 및 커뮤니케이션을 개선
    - DevSecOps: 보안 취약점의 위험을 줄이고 전반적인 보안을 향상시키기 위해 **보안 을 소프트웨어 개발 프로세스에 통합**

### 자동화된 보안

> 사람의 개입 없이 보안 작업을 수행하는 기술을 사용하는 것으로, 보안을 추가한다는 것은 `보안의 자동화 측면` 을 고려하는 것이다.
> 

Ex. 네트워크 위협을 모니터링하고 이를 차단하기 위한 보안 SW를 사용하는 것, 

### 사이버 보안 vs DevSecOps

- 사이버 보안: 디지털 공격, 도난, 손상으로부터 컴퓨터 시스템과 네트워크를 보호하는 관행
- DevSecOps: DevSecOps는 개발, 보안 및 운영 방식의 조합입니다. 보안을 별도의 단계로 취급하지 않고 개발 프로세스에 통합하는 것을 목표로 하는 철학으로, SDLC에 거쳐 개발, 보안, 운영 팀 간의 협업이 포함된다.

|  | 사이버 보안 | DevSecOps |
| --- | --- | --- |
| 초점 | 외부 위협으로부터 시스템을 보호 | 보안을 개발 프로세스에 통합 |
| 범위 | 네트워크 보안, 데이터 보안, 애플리케이션 보안 등 광범위한 주제 | 특히 SW 개발 및 보안을 향상시키는 데 중점 |
| 접근 방식 | 개발 프로세스가 완료된 후 보안 조치를 구현 | 처음부터 보안을 개발 프로세스에 통합하는 작업 |
| 협업 | IT팀과 보안팀 간의 협업 | 개발, 보안, 운영 팀 간의 협업  |

# Day03. 공격자처럼 생각하라

> 공격자에게 모든 비즈니스와 소프트웨어는 공격 대상이다. 안전한 곳은 없다. 공격하기에 덜 매력적인 곳을 만들 수 있을 뿐이다.
> 

### 동기

DevOps 팀은 인프라와 소프트웨어를 프로비저닝하고 플랫폼의 여러 클라우드, 가상화 및 컨테이너화에 걸쳐 이러한 환경을 보호하게 되는데, 이때 다음을 고려해야 한다.

- 그들은 우리를 **어떻게 공격할까요?**
    - 단순히 재미일 수도, 금전적, 정치적 공격일 수도 있다.
- **왜** 우리를 공격할까요?
- 공격자에게 귀중한 것은 **무엇 입니까?**
    - 공격의 중심에는 `데이터`가 있을 가능성이 있다. 이것이 바로 우리가 데이터를 보호하고 암호화하도록 중점을 두는 이유이다.

### 공격 맵(Attack Maps)

홈 네트워크 또는 비즈니스에 대한 공격 맵을 생성하려면 다음을 캡처해야 합니다.

- 사용 중인 모든 통신 흐름과 기술을 포함하여 앱의 그래픽 표현을 캡처합니다.
- 잠재적인 취약점 및 공격 영역 목록입니다.
- 앱 내 각 연결/상호작용에 대한 기밀성, 무결성 및 가용성을 고려하세요.
- 공격/취약점 매핑
- 예시
    
    ![스크린샷 2023-10-11 오후 9.30.05.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/f7e121bd-b3c1-49a3-8fa0-a5ff88b48dbb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.30.05.png)
    

### 지속적 응답 (Continuous Response)

공격맵은 최종적이지 않다. 피드백을 통해 애플리케이션을 지속적으로 업데이트하는 것과 마찬가지로, 공격 맵도 테스트와 피드백을 제공해야한다. 

이것을 보안 피드백 loop에서 지속적 응답이라고 부른다.

- **양호** - 공격을 줄이기 위해 소프트웨어에 내장되어야 하는 보안 설계 제약 조건과 제어를 식별합니다.
- **더 좋음** - 소프트웨어 주기 후반에 발견되는 문제에 대해 우선순위를 지정하고 보안을 구축합니다.
- **최고** - 문제 감지, 단위 테스트, 보안 테스트, 블랙박스 테스트를 위한 스크립트 배포에 자동화 구축

# Day04. 레드 팀 vs 블루 팀

레드팀 : 헛점이나 잘못된 부분을 찾아내는 조직

블루팀 : 헛점이나 잘못된 점을 방어하는 역할 

- 모의 보안 평가를 하는 이유
    - 취약점
    - 네트워크 보안 강화
    - 공격 탐지 및 격리 경험 쌓기
    - 상세한 대응 계획 수립
    - 회사 전반의 보안 인식 제고

옐로우팀: 보안 시스템과 애플리케이션을 개발하는 빌더, 엔지니어 및 개발자

퍼플팀: 방어와 공격을 통합하고 팀 간 협력 및 지식 공유를 하며 더 나은 대안을 찾는다.

그린팀 : 피드백 루프, 블루팀으로부터 통찰력을 얻고 옐로우팀과 협력한다.

오렌지팀: 블루를 위해 협력하는 그린팀과 마찬가지로, 오렌지팀은 레드팀과 협력하여 배운 내용을 옐로우에게 전달하여 더 나은 보안을 구축한다.

![스크린샷 2023-10-11 오후 9.46.33.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/5ae4c9ff-ddc7-4c14-8b02-ac5caa6bb208/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.46.33.png)

![스크린샷 2023-10-11 오후 9.46.39.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/43a11e74-2ce3-46de-8f22-a508c0e43763/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.46.39.png)

![스크린샷 2023-10-11 오후 9.46.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f25870f-f390-4f70-a124-ef604fe567f7/a3b54888-35a7-4c8f-9412-bffd2cf0316b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.46.57.png)

https://hackernoon.com/introducing-the-infosec-colour-wheel-blending-developers-with-red-and-blue-security-teams-6437c1a07700

# Day05. 오픈소스 보안

OSS를 활용하면 애플리케이션 개발 속도를 높이고 상용 제품을 더 빠르게 시장에 출시할 수 있어 오픈소스에 대한 관심과 채택이 급증하고있다. 이에 따라 애플리케이션에 대한 공격 벡터도 증가했기때문에 보안에 대한 전반적인 노력이 필요하다.

**오픈소스 보안**이란 **오픈소스 소프트웨어를 사용하는 컴퓨터 시스템과 네트워크의 안전과 보안을 보장하는 관행**을 의미한다.

# Day06: 취약 앱 빌드