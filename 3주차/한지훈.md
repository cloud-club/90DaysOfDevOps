# laC

## Day 56

- 자동화에 대한 논의.
- 물리 머신, 가상 머신, 클라우드 VM 등의 데이터를 잃는다는 상황을 가정.
- 혹은 이러한 것을 교체하는데 들어가는 리소스가 크다는 점.
- laC는 테스트와 교체를 수행할 수 있는 솔루션.
- 백업과 복구와는 다른 논의.

### 문답
---
laC란 무엇인가?

- Life Cycle Automation and Collaboration의 약자.
- 애플리케이션 라이프사이클 관리와 자동화, 협업을 강조.
- 개발과 운영 팀간의 협업을 의미하게 된다.

---
애플리케이션 라이프사이클이란?

1. 계획) 개발팀과 운영팀의 애플리케이션의 목표와 요구사항을 정의, 일정 자원을 계획하는 단계.
2. 개발) 개발자는 코드를 작성, VC을 이용하여 코드의 변경사항을 추적. laC는 자동화된 빌드 및 테스트 프로세스를 통하여 지원.
3. 테스트) 유닛 테스트, 통합 및 성능 테스트를 포함.
4. 배포) 애플리케이션 운영 환경으로 배포. 롤백 기능도 포함.
5. 운영) 애플리케이션 모니터링, 성능을 관찰하며 문제 해결. laC는 모니터링 및 로깅을 자동화
6. 모니터링 및 피드백) 애플리케이션 모니터링 및 피드백

- 새로운 애플리케이션 빌드를 가정하자. 서버를 수동으로 준비해야 한다.

	- 가상 머신 배포
	- 네트워킹 구성
	- 라우팅 테이블 생성
	- 소프트웨어 및 업데이트 설치
	- 소프트웨어 구성
	- 데이터베이스 구성

- 이러한 작업에 대한 자동화해야한다.
- 유지관리에도 다양한 일이 필요하다.


	- 버전 업데이트
	- 릴리즈 배포
	- 데이터 관리
	- 애플리케이션 복구
	- 서버 추가 및 제거, 확장
	- 네트워크 구성 등

- laC는 구성에서부터 유지 관리 작업에서도 자동화를 이룩할 수 있음.

### 문답
---
LAC (Life Cycle Automation and Collaboration)의 전체과정을 웹 애플리케이션 스택을 예로 들어 설명해 드리겠습니다. 이 예에서는 장고(Django) 프레임워크를 사용하도록 하겠습니다.

1. **계획 (Plan)**:
   - 프로젝트 관리 및 협업 도구: Jira, Trello, 또는 Asana 등을 사용하여 프로젝트 계획을 수립하고 일정을 관리합니다.
   - 협업 도구: Slack 또는 Microsoft Teams와 같은 메시징 및 협업 도구를 사용하여 팀 간 의사 소통을 촉진합니다.

2. **개발 (Develop)**:
   - 웹 애플리케이션 프레임워크: 장고(Django)를 사용하여 웹 애플리케이션을 개발합니다.
   - 코드 버전 관리: Git과 GitHub 또는 GitLab과 같은 플랫폼을 사용하여 코드 변경 사항을 추적하고 협업합니다.

3. **테스트 (Test)**:
   - 자동화된 테스트 프레임워크: Django의 내장 테스트 프레임워크 또는 Selenium과 같은 자동화 테스트 도구를 사용하여 단위 테스트, 통합 테스트 및 기능 테스트를 수행합니다.

4. **배포 (Deploy)**:
   - 배포 스크립트: Ansible 또는 Docker와 Kubernetes와 같은 배포 자동화 도구를 사용하여 애플리케이션을 운영 서버에 배포합니다.
   - 웹 서버: Nginx 또는 Apache와 같은 웹 서버를 사용하여 애플리케이션을 호스팅합니다.
   - 데이터베이스: PostgreSQL 또는 MySQL과 같은 데이터베이스를 사용하여 데이터를 관리합니다.

5. **운영 (Operate)**:
   - 모니터링 도구: Prometheus와 Grafana를 사용하여 애플리케이션 및 인프라를 모니터링하고 성능을 관찰합니다.
   - 로깅 및 알림: ELK 스택 (Elasticsearch, Logstash, Kibana)를 사용하여 로그를 수집하고 알림을 관리합니다.

6. **모니터링 및 피드백 (Monitor & Feedback)**:
   - 사용자 피드백: 앱 내부에서 또는 사용자로부터 피드백을 수집하고 이를 분석하여 애플리케이션 개선에 반영합니다.
   - 지속적인 통합/지속적인 배포 (CI/CD): Jenkins 또는 GitLab CI/CD와 같은 도구를 사용하여 지속적인 통합과 배포 파이프라인을 설정하여 개발 및 배포 프로세스를 자동화합니다.

이렇게 LAC를 적용한 웹 애플리케이션 스택에서 각 단계에서 사용되는 주요 라이브러리와 도구에 대한 예시를 제공했습니다. 이러한 도구 및 프레임워크는 개발 및 운영 과정을 자동화하고 협업을 강화하는 데 중요한 역할을 합니다.
---

- Terraform은 배포 단계에서 사용된다.
- 이는 인프라스트럭처를 코드로 정의 관리할 수 있게 해준다.

## Day 57

### Terraform
---

- 인프라의 안전하고 효율적인 구축
- API를 사용하여 클라우드 관리. 빠른 프로비저닝. (프로비저닝은 새로운 가상 서버, 가상머신을 생성하고 구성하는 프로세스.)

- Terraform은 프로비저닝을 중심으로. 복잡한 인프라 요구 사항 정의.

- 쓰기) Terraform을 사용하면 환경을 구축할 선언적 구성 파일
- 계획) 배포할 것인지 확인하기 위해 배포하거나 변경하기 전에 해당 계획을 테스트할 수 있는 기능
- 적용) Terraform 내에서 사용할 수 있는 많은 제공업체에 적용


---

- 그렇다면 Vagrant와의 차이는 어떻게 되는가?

- 테라폼은 클라우드 인프라스트럭처에 중심을 둔다. 프로비저닝과 스케일링 과정에 중심적.
- 바그란트는 개발환경 관리. 로컬 개발 머신에 중심을 둔다.

=> 중심적인 사항은 배포의 환경이 될 것으로 보인다.


## Day 58
---


- 저는 아래코드를 조금씩 변화하면서 사용하겠습니다. 물론 aws을 통해서 코드를 분석하기만도 해야죠. 

- HCL에 대해서 알아봐야한다.
- 가상 머신 자동 배포 등의 인프라, VPC 및 보안 그룹의 네트워킹 필수 자산을 생성할 수 있다.
- 테라폼에서의 측면에서는 code와 state이다.


- 공급자 코드 (테라폼 레지스트리에서 사용할 수 있는 제공자.)

``` HCL
terraform {
  required_providers {
    oci = {
      source  = "hashicorp/oci"
      version = "~> 4.0"  # 사용 가능한 최신 버전으로 변경
    }
  }
}
```

``` HCL
provider "oci" {
  region = "ap-seoul-1" // 서울 리전 설정
}
```

- Terraform 리소스

- 인스턴스, 로드 밸런서, VPC 등, 하나 이상의 인프라 개체를 설명
- 리소스 블록은 지정된 유형과 리소스로 지정된 로컬 이름으로 선언
- 유형과 이름은 함께 식별자 역할

```HCL
resource "aws_instance" "90daysofdevops" {
  ami               = data.aws_ami.instance_id.id
  instance_type     = "t2.micro"
  availability_zone = "us-west-2a"
  security_groups   = [aws_security_group.allow_web.name]
  user_data         = <<-EOF
                #! /bin/bash
                sudo yum update
                sudo yum install -y httpd
                sudo systemctl start httpd
                sudo systemctl enable httpd
                echo "
<h1>Deployed via Terraform</h1>

" | sudo tee /var/www/html/index.html
        EOF
  tags = {
    Name = "Created by Terraform"
  }
}
```
이 코드는 테라폼을 사용하여 AWS에서 EC2 인스턴스를 생성하고 웹 서버를 설정하는 것을 목표로 합니다. 코드의 각 라인을 설명하겠습니다:

1. `resource "aws_instance" "90daysofdevops"`: 이 부분은 테라폼에서 AWS EC2 인스턴스 리소스를 정의하는 시작입니다. "90daysofdevops"는 이 리소스의 이름입니다.

2. `ami = data.aws_ami.instance_id.id`: 이 부분은 인스턴스에 사용할 AMI (Amazon Machine Image)를 설정합니다. `data.aws_ami.instance_id.id`는 이미지의 ID를 가져오는 데이터 소스로부터 값을 사용하고 있습니다. 즉, 이 AMI는 이미지 ID에 따라 결정됩니다.

3. `instance_type = "t2.micro"`: 이 부분은 인스턴스 유형을 설정합니다. "t2.micro"는 가벼운 인스턴스 유형을 나타냅니다.

4. `availability_zone = "us-west-2a"`: 이 부분은 인스턴스가 배치될 가용 영역을 설정합니다. "us-west-2a"는 미국 서부 지역의 가용 영역을 나타냅니다.

5. `security_groups = [aws_security_group.allow_web.name]`: 이 부분은 보안 그룹을 설정합니다. `aws_security_group.allow_web.name`은 이 인스턴스에 적용될 보안 그룹의 이름을 지정하고 있습니다. 이것은 웹 트래픽을 허용하는 보안 그룹으로 설정될 것입니다.

6. `user_data`: 이 부분은 인스턴스가 시작될 때 실행되는 사용자 데이터 스크립트를 정의합니다. 이 스크립트는 다음을 수행합니다:
   - 시스템 업데이트를 수행합니다.
   - Apache 웹 서버 (`httpd`)를 설치하고 시작합니다.
   - 웹 서버의 기본 페이지에 "Deployed via Terraform" 메시지를 추가합니다.

7. `tags`: 이 부분은 EC2 인스턴스에 태그를 추가합니다. 이 경우, "Name" 태그가 "Created by Terraform"로 설정됩니다.

---

terraform init 명령어는 테라폼 코드가 있는 모든 디렉토리에서 테라폼 코드를 실행하기 전에 수행하는 명령어 입니다.

- Provider 설정을 로드합니다. : 해당 인프라 제공자에 대해서 필요한 플러그인을 다운로드 합니다.

---

terraform plan을 통해서 실행 계획을 생성하여 줍니다.

- 변경사항을 미리 확인하고 시뮬레이션 할 수 있습니다.

```HCL
provider "aws" {
  region = "us-west-2"
}

resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
}
```

```HCL
Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but
will not be persisted to local or remote state storage.

aws_instance.example: Creating...

───────────────────────────────────────────────────────────────────────

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.example will be created
  + resource "aws_instance" "example" {
      + ami                          = "ami-0c55b159cbfafe1f0"
      + arn                          = (known after apply)
      + associate_public_ip_address  = (known after apply)
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "t2.micro"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = (known after apply)
      + network_interface_ids        = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + secondary_private_ips        = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tenancy                      = (known after apply)
      + user_data                    = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = true
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
    ...
      }

      + enclave_options {
          + enabled = (known after apply)
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.
```
---

- terraform apply는 실제 적용합니다.

``` HCL
aws_instance.example: Creating...
aws_instance.example: Still creating... [10s elapsed]
aws_instance.example: Creation complete after 20s [id=i-0123456789abcdef0]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.

Outputs:

public_ip = "1.2.3.4"
```

- `aws_instance.example: Creating...`: 이 부분은 테라폼이 "aws_instance.example" 리소스를 생성 중임을 보여줍니다. 인스턴스 생성 작업이 시작되었습니다.

- `aws_instance.example: Still creating... [10s elapsed]`: 인스턴스 생성이 진행 중임을 알려주며, 경과한 시간을 표시합니다. 여기서는 10초가 지났습니다.

- `aws_instance.example: Creation complete after 20s [id=i-0123456789abcdef0]`: 인스턴스 생성이 완료되었음을 알려주며, 인스턴스의 고유 ID가 "i-0123456789abcdef0"인 것을 나타냅니다.

- `Apply complete! Resources: 1 added, 0 changed, 0 destroyed.`: `terraform apply` 작업이 완료되었으며, 1개의 리소스가 추가되었고 변경 또는 삭제된 리소스는 없음을 나타냅니다.

- `Outputs:`: 이 부분은 출력 변수를 나열합니다.

- `public_ip = "1.2.3.4"`: 출력 변수의 값이 표시되며, 이 경우 "public_ip" 변수의 값은 "1.2.3.4"입니다.

`terraform apply`를 실행하면 코드에서 정의한 인프라 리소스가 생성되거나 업데이트되며, 이러한 변경 사항을 테라폼이 추적하고 관리합니다.

---
```bash
root@instance-20230925-2110:~/terraform# terraform init

Initializing the backend...

Initializing provider plugins...

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
root@instance-20230925-2110:~/terraform# terraform plan

Changes to Outputs:
  + hello_world = "Hello, 90DaysOfDevOps from Terraform"

You can apply this plan to save these new output values to the Terraform state, without changing any
real infrastructure.

────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly
these actions if you run "terraform apply" now.
root@instance-20230925-2110:~/terraform# terraform apply

Changes to Outputs:
  + hello_world = "Hello, 90DaysOfDevOps from Terraform"

You can apply this plan to save these new output values to the Terraform state, without changing any
real infrastructure.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes


Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

Outputs:

hello_world = "Hello, 90DaysOfDevOps from Terraform"
```
```bash
root@instance-20230925-2110:~/terraform# terraform destroy 

Changes to Outputs:
  - hello_world = "Hello, 90DaysOfDevOps from Terraform" -> null

You can apply this plan to save these new output values to the Terraform state, without changing any
real infrastructure.

Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value: yes 


Destroy complete! Resources: 0 destroyed.
```

### Terraform state

``` bash
root@instance-20230925-2110:~/terraform# cat terraform.tfstate
{
  "version": 4,
  "terraform_version": "1.5.7",
  "serial": 3,
  "lineage": "1b645385-ca46-1761-ee3a-ca88db419342",
  "outputs": {
    "hello_world": {
      "value": "Hello, 90DaysOfDevOps from Terraform",
      "type": "string"
    }
  },
  "resources": [],
  "check_results": null
}
```
Terraform의 `.tfstate` 파일은 Terraform이 관리하는 인프라 리소스의 현재 상태를 저장하는 중요한 파일입니다. 이 파일은 JSON 형식 또는 이진 형식으로 저장될 수 있으며, 주로 로컬 디렉토리에 저장되거나 원격 백엔드에 저장됩니다. `.tfstate` 파일은 다음과 같은 내용을 포함합니다:

1. **리소스 상태 정보**: `.tfstate` 파일은 Terraform이 관리하는 각 리소스(예: EC2 인스턴스, VPC, S3 버킷 등)의 상태 정보를 포함합니다. 이 정보에는 리소스의 ID, 속성(예: IP 주소, 이름), 및 Terraform이 리소스를 관리하기 위해 필요한 기타 정보가 포함됩니다.

2. **버전 정보**: `.tfstate` 파일에는 Terraform 버전 및 상태 파일 형식 버전 정보가 포함되어 있습니다. 이는 테라폼의 버전 호환성을 관리하는 데 중요합니다.

3. **종속성 정보**: 각 리소스는 다른 리소스에 대한 종속성 정보를 가질 수 있습니다. 예를 들어, EC2 인스턴스는 특정 서브넷에 종속될 수 있습니다. 이 종속성 정보는 리소스 간의 관계를 설명하고 Terraform이 리소스를 생성 또는 업데이트하는 순서를 결정하는 데 사용됩니다.

4. **입력 변수 값**: Terraform 코드에 정의된 입력 변수(예: 사용자 데이터, AMI ID)의 현재 값도 `.tfstate` 파일에 포함됩니다. 이는 코드와 인프라의 상태 간의 일관성을 유지하는 데 도움이 됩니다.

`.tfstate` 파일은 Terraform 실행 중에 자동으로 업데이트되며, `terraform apply`나 `terraform plan`과 같은 명령어를 실행할 때 이 파일을 읽어 현재 상태와 비교합니다. 이를 통해 Terraform은 변경 사항을 식별하고 원하는 상태로 인프라를 조정합니다.

주의할 점은 `.tfstate` 파일에는 민감한 정보가 포함될 수 있으므로 보안을 유지해야 합니다. 특히 액세스 키, 보안 그룹 룰 등의 비밀 정보는 `.tfstate` 파일에 노출되지 않도록 주의해야 합니다. 보안을 강화하기 위해 원격 백엔드를 사용하여 `.tfstate` 파일을 안전하게 보관하는 것이 일반적인 관행입니다.

---
## Day59

- Terraform을 이용하여 Virtual Box VM 생성하는 예시.
- terraform.tfvars 등을 이용하여 환경변수를 파일로 지정하여 apply 혹은 plan 단계에서 사용가능.

---

## Day60

- Terraform을 이용하여 docker 컨테이너를 생성하는 예시.

```shell

root@instance-20230925-2110:~# docker ps
CONTAINER ID   IMAGE              COMMAND                  CREATED        STATUS        PORTS                  NAMES
66de858cce2c   mysql:5.7          "docker-entrypoint.s…"   40 hours ago   Up 40 hours   3306/tcp, 33060/tcp    db
0a07ad7ed7e8   wordpress:latest   "docker-entrypoint.s…"   40 hours ago   Up 40 hours   0.0.0.0:8080->80/tcp   wordpress
69bae5a819ad   61395b4c586d       "/docker-entrypoint.…"   40 hours ago   Up 40 hours   0.0.0.0:8000->80/tcp   tutorial

```

### Provisioners

- 인프라를 생성하거나 변경후에 추가적인 동작을 수행하는데 이용.
- create => 리소스 생성 후 실행, 초기 설정 및 구성에 이용
- destroy => 인프라 리소스가 삭제되기 전 실행

### 모듈

- 여러 리소스 사용 시에 대해서 동일한 디렉토리에 있는 .tf 파일을 사용할 수 있음.

---

# Day 61

## Kubernetes 와 다중환경

- 가상 머신의 모양을 코드에서 정의한 다음 배포한다는 전제는 실제로 동일
- Terraform을 사용하여 Kubernetes 클러스터 내의 객체와 상호 작용

### 해당부분 문답

이 Terraform 코드는 쿠버네티스 환경을 구축하기 위한 구성 파일입니다. 코드를 라인별로 분석해보겠습니다:

1. `terraform` 블록:
   - Terraform 설정 블록으로 시작합니다.
   - 필수 제공자를 정의합니다.

2. `required_providers` 블록:
   - kubernetes 제공자를 필요로 함을 명시합니다.
   - `hashicorp/kubernetes` 소스에서 버전 2.0.0 이상을 사용하도록 지정합니다.

3. `provider "kubernetes"` 블록:
   - kubernetes 제공자를 구성합니다.
   - `config_path`를 통해 Kubernetes 설정 파일 (`~/.kube/config`)의 위치를 지정합니다.

4. `resource "kubernetes_namespace" "test"` 블록:
   - Kubernetes 네임스페이스를 정의합니다.
   - `metadata` 블록 아래에서 네임스페이스의 이름을 "nginx"로 설정합니다.

5. `resource "kubernetes_deployment" "test"` 블록:
   - Kubernetes 배포 (Deployment)를 정의합니다.
   - `metadata` 블록에서 배포의 이름을 "nginx"로, 네임스페이스를 이전에 정의한 네임스페이스의 이름으로 설정합니다.
   - `spec` 블록에서 배포의 세부 설정을 정의합니다.
     - `replicas`는 2개의 복제본을 생성하도록 설정합니다.
     - `selector` 블록은 이 배포의 파드를 선택하기 위한 라벨을 정의합니다.
     - `template` 블록에서 파드의 템플릿을 정의하며, 여기서는 Nginx 컨테이너를 사용합니다.

6. `resource "kubernetes_service" "test"` 블록:
   - Kubernetes 서비스를 정의합니다.
   - `metadata` 블록에서 서비스의 이름을 "nginx"로, 네임스페이스를 이전에 정의한 네임스페이스의 이름으로 설정합니다.
   - `spec` 블록에서 서비스의 세부 설정을 정의합니다.
     - `selector` 블록은 이 서비스가 어떤 파드를 대상으로 하는지를 선택하기 위한 라벨을 정의합니다.
     - `type`은 서비스 유형을 "NodePort"로 설정합니다.
     - `port` 블록에서 노드 포트와 대상 포트를 설정합니다.

이 코드는 Kubernetes 클러스터에서 "nginx" 네임스페이스에 Nginx 애플리케이션을 배포하고, 해당 서비스를 노드 포트를 통해 노출시키는 구성을 정의합니다.

---

# Day 62

## 테스트, 도구 및 대안.

### Code Rot

- 애플리케이션 코드와 달리 코드로서의 인프라는 한 번 사용되었다가 오랫동안 사용하지 않을 수도 있습니다

```text

WHY?

"Code Rot"은 인프라 코드를 나타내는 것으로, 애플리케이션 코드와는 다릅니다. 애플리케이션 코드는 지속적으로 개발, 업데이트 및 유지보수되지만 인프라 코드는 다르게 작동합니다. 이를 예시를 통해 설명하겠습니다.

가령, 개발자가 Terraform을 사용하여 클라우드 인프라를 생성하는 코드를 작성했다고 가정해 봅시다. 이 코드는 다음과 같은 작업을 수행합니다.
1. 가상 머신 인스턴스 생성
2. 로드 밸런서 구성
3. 데이터베이스 클러스터 설정
4. 기타 클라우드 리소스 생성

이 인프라 코드는 초기에는 원활하게 작동하고, 개발 및 테스트 환경을 구축하는 데 사용됩니다. 그러나 이후 몇 달 동안 또는 앱의 요구 사항이 변경되지 않는 한 이 코드는 변경되지 않을 가능성이 높습니다. 이 시간 동안에는 다음과 같은 문제가 발생할 수 있습니다.

1. **리소스 업데이트 누락**: 클라우드 제공자가 새로운 인스턴스 유형을 도입하거나 서비스 업데이트를 배포할 때, 이러한 업데이트를 인프라 코드에 적용하지 않으면 최신 기능을 활용할 수 없습니다.

2. **보안 업데이트 누락**: 클라우드 서비스나 운영 체제에 대한 보안 업데이트가 나올 때, 인프라 코드를 업데이트하지 않으면 시스템에 보안 취약점이 남아 있을 수 있습니다.

3. **설정 관리 어려움**: 초기에는 잘 동작하던 설정이나 네트워크 규칙이 나중에 앱의 요구 사항 변경으로 인해 더 이상 적합하지 않을 수 있습니다.

4. **문서화 부족**: 코드를 사용하지 않는 동안 코드의 의도나 작동 방식에 대한 문서화가 부족하거나 유지되지 않을 수 있으며, 새로운 팀원들에게 이해하기 어려울 수 있습니다.

이런 이유로 인프라 코드는 주기적으로 검토하고 업데이트해야 하며, 코드의 로텐(무너짐)을 방지하기 위해 지속적 통합 및 지속적 배포 (CI/CD)와 같은 개발 관행을 적용하는 것이 좋습니다.

```

